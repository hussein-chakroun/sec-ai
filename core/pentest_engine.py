"""
Autonomous Pentesting Engine
"""
from typing import Dict, Any, List, Optional
from loguru import logger
from datetime import datetime
import asyncio

from core.llm_orchestrator import LLMOrchestrator
from modules import NmapScanner, SQLMapScanner, HydraCracker, MetasploitFramework


class PentestEngine:
    """Main autonomous pentesting engine"""
    
    def __init__(self, orchestrator: LLMOrchestrator):
        self.orchestrator = orchestrator
        self.nmap = NmapScanner()
        self.sqlmap = SQLMapScanner()
        self.hydra = HydraCracker()
        self.metasploit = MetasploitFramework()
        
        self.scan_results = []
        self.target = None
        self.context = {}
        
        logger.info("Pentest Engine initialized")
    
    def check_tools(self) -> Dict[str, bool]:
        """Check which tools are installed"""
        tools_status = {
            "nmap": self.nmap.check_installed(),
            "sqlmap": self.sqlmap.check_installed(),
            "hydra": self.hydra.check_installed(),
            "metasploit": self.metasploit.check_installed()
        }
        
        logger.info(f"Tools status: {tools_status}")
        return tools_status
    
    def install_missing_tools(self, auto_install: bool = False) -> Dict[str, Any]:
        """
        Attempt to install missing tools
        
        Args:
            auto_install: If True, install without confirmation
            
        Returns:
            Dict with installation results
        """
        tools_status = self.check_tools()
        missing_tools = [name for name, installed in tools_status.items() if not installed]
        
        if not missing_tools:
            logger.info("All tools are already installed")
            return {"success": True, "message": "All tools installed", "installed": []}
        
        logger.info(f"Missing tools: {missing_tools}")
        
        tool_map = {
            "nmap": self.nmap,
            "sqlmap": self.sqlmap,
            "hydra": self.hydra,
            "metasploit": self.metasploit
        }
        
        results = {
            "attempted": [],
            "succeeded": [],
            "failed": [],
            "skipped": []
        }
        
        for tool_name in missing_tools:
            tool = tool_map.get(tool_name)
            
            if not tool:
                results["skipped"].append(tool_name)
                continue
            
            results["attempted"].append(tool_name)
            logger.info(f"Attempting to install {tool_name}...")
            
            try:
                success = tool.attempt_install()
                
                if success:
                    results["succeeded"].append(tool_name)
                    logger.info(f"✅ Successfully installed {tool_name}")
                else:
                    results["failed"].append(tool_name)
                    logger.warning(f"❌ Failed to install {tool_name}")
            
            except Exception as e:
                results["failed"].append(tool_name)
                logger.error(f"❌ Error installing {tool_name}: {e}")
        
        return {
            "success": len(results["succeeded"]) > 0,
            "results": results,
            "message": f"Installed {len(results['succeeded'])}/{len(missing_tools)} tools"
        }
    
    def run_pentest(self, target: str, max_iterations: int = 10) -> Dict[str, Any]:
        """Run autonomous penetration test"""
        self.target = target
        self.scan_results = []
        
        logger.info(f"Starting autonomous pentest against {target}")
        logger.info(f"Max iterations: {max_iterations}")
        if self.orchestrator.low_context_mode:
            logger.info("⚠️  Low context mode enabled - processing will be sequential and slower")
        
        # Phase 1: Initial analysis
        logger.info("Phase 1: Analyzing target")
        analysis = self.orchestrator.analyze_target(target)
        self.context["initial_analysis"] = analysis
        
        # Phase 2: Initial reconnaissance
        logger.info("Phase 2: Initial reconnaissance")
        recon_result = self._run_reconnaissance()
        self.scan_results.append({
            "timestamp": datetime.now().isoformat(),
            "phase": "reconnaissance",
            "tool": "nmap",
            "result": recon_result
        })
        
        # Phase 3: Iterative autonomous scanning
        logger.info("Phase 3: Autonomous scanning and exploitation")
        iteration = 0
        consecutive_failures = 0  # Track consecutive failed iterations
        
        while iteration < max_iterations:
            iteration += 1
            logger.info(f"Iteration {iteration}/{max_iterations}")
            
            # In low context mode, process one step at a time with delays
            if self.orchestrator.low_context_mode:
                logger.info("⏳ Processing in low context mode - waiting for LLM...")
            
            # Ask LLM what to do next
            decision = self.orchestrator.decide_next_action(
                self.scan_results[-1]["result"],
                context=self.context
            )
            
            logger.info(f"Decision: {decision}")
            
            # Check if fallback was used (indicates LLM parsing issues)
            if decision.get("_fallback_used"):
                logger.warning("⚠️  Using fallback decision due to LLM response parsing issues")
                if decision.get("_raw_response"):
                    logger.debug(f"Raw LLM response: {decision['_raw_response'][:200]}...")
            
            # Check if we should stop
            tool = decision.get("tool", "").lower()
            if tool == "none" or tool == "conclude":
                logger.info(f"Assessment concluded: {decision.get('reasoning', 'No reason provided')}")
                break
            
            # In low context mode, wait before executing tool
            if self.orchestrator.low_context_mode:
                logger.info(f"⏳ Executing {tool} and waiting for completion...")
            
            # Execute the decided action
            result = self._execute_tool(tool, decision.get("parameters", {}))
            
            if result and result.get("success") is not False:
                self.scan_results.append({
                    "timestamp": datetime.now().isoformat(),
                    "phase": f"iteration_{iteration}",
                    "tool": tool,
                    "decision": decision,
                    "result": result
                })
                
                consecutive_failures = 0  # Reset failure counter on success
                
                # In low context mode, provide progress update
                if self.orchestrator.low_context_mode:
                    logger.info(f"✅ Step {iteration} completed successfully")
            else:
                consecutive_failures += 1
                logger.warning(f"Failed to execute tool: {tool} (consecutive failures: {consecutive_failures})")
                
                # If we've had too many consecutive failures, stop
                if consecutive_failures >= 3:
                    logger.error("Too many consecutive failures, stopping iteration")
                    break
        
        # Phase 4: Generate recommendations
        logger.info("Phase 4: Generating final report")
        recommendations = self.orchestrator.generate_recommendations(self.scan_results)
        
        final_results = {
            "target": target,
            "start_time": self.scan_results[0]["timestamp"],
            "end_time": datetime.now().isoformat(),
            "total_iterations": iteration,
            "scan_results": self.scan_results,
            "recommendations": recommendations,
            "context": self.context
        }
        
        logger.info("Autonomous pentest completed")
        return final_results
    
    def _run_reconnaissance(self) -> Dict[str, Any]:
        """Run initial reconnaissance"""
        logger.info("Running nmap service scan")
        result = self.nmap.service_scan(self.target)
        
        # Store interesting findings in context
        if result.get("success") and result.get("parsed"):
            parsed = result["parsed"]
            self.context["open_ports"] = parsed.get("open_ports", [])
            self.context["services"] = parsed.get("services", [])
            self.context["os"] = parsed.get("os_detection")
        
        return result
    
    def _execute_tool(self, tool: str, parameters: Any) -> Optional[Dict[str, Any]]:
        """Execute a pentesting tool based on LLM decision"""
        try:
            # Handle both dict and legacy list parameter formats
            if isinstance(parameters, list):
                logger.warning(f"Converting legacy list parameters to dict: {parameters}")
                # Convert list to dict with default scan_type
                parameters = {"scan_type": "custom", "flags": parameters}
            elif parameters is None:
                parameters = {}
            elif not isinstance(parameters, dict):
                logger.warning(f"Unexpected parameter type {type(parameters)}: {parameters}")
                parameters = {}
            
            logger.info(f"Executing {tool} with parameters: {parameters}")
            
            if tool == "nmap":
                return self._execute_nmap(parameters)
            elif tool == "sqlmap":
                return self._execute_sqlmap(parameters)
            elif tool == "hydra":
                return self._execute_hydra(parameters)
            elif tool == "metasploit":
                return self._execute_metasploit(parameters)
            else:
                logger.error(f"Unknown tool: {tool}")
                return None
                
        except Exception as e:
            logger.error(f"Error executing {tool}: {e}")
            import traceback
            logger.debug(traceback.format_exc())
            return {"error": str(e), "success": False}
    
    def _execute_nmap(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute nmap scan"""
        scan_type = params.get("scan_type", "service")
        
        if scan_type == "quick":
            return self.nmap.quick_scan(self.target)
        elif scan_type == "service":
            return self.nmap.service_scan(self.target)
        elif scan_type == "full":
            return self.nmap.full_scan(self.target)
        elif scan_type == "vuln":
            return self.nmap.vulnerability_scan(self.target)
        else:
            flags = params.get("flags", ["-sV"])
            return self.nmap.custom_scan(self.target, flags)
    
    def _execute_sqlmap(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute sqlmap scan"""
        url = params.get("url", f"http://{self.target}")
        action = params.get("action", "test")
        
        if action == "test":
            return self.sqlmap.test_url(
                url,
                data=params.get("data"),
                cookie=params.get("cookie")
            )
        elif action == "dump":
            return self.sqlmap.dump_database(
                url,
                database=params.get("database"),
                table=params.get("table")
            )
        elif action == "dbs":
            return self.sqlmap.get_dbs(url)
        else:
            return self.sqlmap.custom_scan(url, params.get("flags", []))
    
    def _execute_hydra(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute hydra attack"""
        service = params.get("service", "ssh")
        
        if service == "ssh":
            return self.hydra.crack_ssh(
                self.target,
                username=params.get("username"),
                userlist=params.get("userlist"),
                password=params.get("password"),
                passlist=params.get("passlist"),
                port=params.get("port", 22)
            )
        elif service == "ftp":
            return self.hydra.crack_ftp(
                self.target,
                username=params.get("username"),
                userlist=params.get("userlist"),
                password=params.get("password"),
                passlist=params.get("passlist"),
                port=params.get("port", 21)
            )
        else:
            return self.hydra.custom_attack(
                self.target,
                service,
                params.get("flags", [])
            )
    
    def _execute_metasploit(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """Execute metasploit module"""
        action = params.get("action", "search")
        
        if action == "search":
            query = params.get("query", "")
            return self.metasploit.search_exploits(query)
        elif action == "exploit":
            return self.metasploit.run_exploit(
                params.get("exploit_path"),
                self.target,
                payload=params.get("payload"),
                options=params.get("options")
            )
        elif action == "auxiliary":
            return self.metasploit.run_auxiliary(
                params.get("module_path"),
                self.target,
                options=params.get("options")
            )
        elif action == "check":
            return self.metasploit.check_vulnerability(
                self.target,
                params.get("check_module")
            )
        else:
            logger.error(f"Unknown metasploit action: {action}")
            return {"error": "Unknown action", "success": False}
