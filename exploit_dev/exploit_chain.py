"""
Exploit Chain Constructor
Chains multiple vulnerabilities into complete exploit
"""

import logging
from typing import Dict, List, Any, Optional

logger = logging.getLogger(__name__)


class ExploitChainConstructor:
    """
    Constructs multi-stage exploit chains
    Combines multiple vulnerabilities for full compromise
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.architecture = config.get('architecture', 'x86_64')
        self.os = config.get('os', 'linux')
        
    async def construct_chain(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Construct exploit chain from vulnerabilities
        
        Args:
            vulnerabilities: List of discovered vulnerabilities
            
        Returns:
            Complete exploit chain
        """
        logger.info(f"Constructing exploit chain from {len(vulnerabilities)} vulnerabilities")
        
        # Analyze and order vulnerabilities
        ordered_vulns = self._order_vulnerabilities(vulnerabilities)
        
        chain = {
            'stages': [],
            'description': '',
            'reliability': 'unknown',
            'impact': 'unknown'
        }
        
        # Build multi-stage exploit
        for i, vuln in enumerate(ordered_vulns):
            stage = await self._create_stage(vuln, i, chain)
            if stage:
                chain['stages'].append(stage)
        
        # Determine overall impact
        chain['impact'] = self._assess_impact(chain['stages'])
        chain['reliability'] = self._assess_reliability(chain['stages'])
        
        # Generate description
        chain['description'] = self._generate_description(chain)
        
        logger.info(f"Exploit chain constructed: {len(chain['stages'])} stages, impact: {chain['impact']}")
        
        return chain
    
    def _order_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Order vulnerabilities for optimal chaining"""
        
        # Categorize vulnerabilities
        info_leaks = []
        auth_bypasses = []
        code_exec = []
        privilege_esc = []
        others = []
        
        for vuln in vulnerabilities:
            vuln_type = vuln.get('type', '').lower()
            
            if 'leak' in vuln_type or 'disclosure' in vuln_type:
                info_leaks.append(vuln)
            elif 'auth' in vuln_type or 'bypass' in vuln_type:
                auth_bypasses.append(vuln)
            elif 'exec' in vuln_type or 'rce' in vuln_type or 'overflow' in vuln_type:
                code_exec.append(vuln)
            elif 'privilege' in vuln_type or 'escalation' in vuln_type:
                privilege_esc.append(vuln)
            else:
                others.append(vuln)
        
        # Optimal order: info leak -> auth bypass -> code exec -> privilege escalation
        ordered = info_leaks + auth_bypasses + code_exec + privilege_esc + others
        
        return ordered
    
    async def _create_stage(self, vuln: Dict[str, Any], stage_num: int, 
                           chain: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Create exploit stage for vulnerability"""
        
        vuln_type = vuln.get('type', '').lower()
        
        stage = {
            'number': stage_num + 1,
            'name': f"Stage {stage_num + 1}: {vuln_type}",
            'vulnerability': vuln,
            'actions': [],
            'prerequisites': [],
            'outcomes': []
        }
        
        # Define stage based on vulnerability type
        if 'leak' in vuln_type:
            stage['actions'] = [
                'Trigger information disclosure',
                'Parse leaked data',
                'Extract addresses/credentials'
            ]
            stage['outcomes'] = ['address_leak', 'credential_leak']
            
        elif 'auth' in vuln_type or 'bypass' in vuln_type:
            stage['actions'] = [
                'Bypass authentication mechanism',
                'Obtain valid session/token',
                'Access protected resources'
            ]
            stage['outcomes'] = ['authenticated_access']
            
        elif 'overflow' in vuln_type or 'exec' in vuln_type:
            # Check if we have necessary info from previous stages
            has_address = any('address_leak' in s.get('outcomes', []) 
                            for s in chain.get('stages', []))
            
            if has_address or not vuln.get('security_features', {}).get('pie'):
                stage['actions'] = [
                    'Trigger buffer overflow',
                    'Overwrite return address',
                    'Execute shellcode/ROP chain',
                    'Achieve code execution'
                ]
                stage['outcomes'] = ['code_execution']
            else:
                stage['prerequisites'] = ['address_leak']
                logger.info(f"Stage {stage_num + 1} requires address leak")
                
        elif 'privilege' in vuln_type:
            stage['prerequisites'] = ['code_execution']
            stage['actions'] = [
                'Exploit privilege escalation vulnerability',
                'Elevate to root/SYSTEM',
                'Establish persistence'
            ]
            stage['outcomes'] = ['privilege_escalation', 'full_compromise']
        
        return stage
    
    def _assess_impact(self, stages: List[Dict[str, Any]]) -> str:
        """Assess overall impact of exploit chain"""
        
        outcomes = set()
        for stage in stages:
            outcomes.update(stage.get('outcomes', []))
        
        if 'full_compromise' in outcomes or 'privilege_escalation' in outcomes:
            return 'critical'
        elif 'code_execution' in outcomes:
            return 'high'
        elif 'authenticated_access' in outcomes:
            return 'medium'
        elif 'address_leak' in outcomes:
            return 'low'
        else:
            return 'info'
    
    def _assess_reliability(self, stages: List[Dict[str, Any]]) -> str:
        """Assess reliability of exploit chain"""
        
        # More stages = less reliable
        if len(stages) == 1:
            return 'high'
        elif len(stages) <= 3:
            return 'medium'
        else:
            return 'low'
    
    def _generate_description(self, chain: Dict[str, Any]) -> str:
        """Generate human-readable description of exploit chain"""
        
        description = f"Multi-stage exploit chain with {len(chain['stages'])} stages:\n\n"
        
        for stage in chain['stages']:
            description += f"{stage['name']}:\n"
            for action in stage['actions']:
                description += f"  - {action}\n"
            description += "\n"
        
        description += f"Overall Impact: {chain['impact'].upper()}\n"
        description += f"Reliability: {chain['reliability'].upper()}"
        
        return description
    
    def visualize_chain(self, chain: Dict[str, Any]) -> str:
        """
        Create ASCII visualization of exploit chain
        
        Args:
            chain: Exploit chain
            
        Returns:
            ASCII diagram
        """
        viz = "Exploit Chain Visualization:\n"
        viz += "=" * 50 + "\n\n"
        
        for i, stage in enumerate(chain['stages']):
            viz += f"[Stage {stage['number']}]\n"
            viz += f"{stage['name']}\n"
            
            # Show prerequisites
            if stage.get('prerequisites'):
                viz += f"Requires: {', '.join(stage['prerequisites'])}\n"
            
            viz += "    |\n"
            viz += "    v\n"
        
        viz += "[SUCCESS]\n"
        viz += f"Impact: {chain['impact']}\n"
        
        return viz
