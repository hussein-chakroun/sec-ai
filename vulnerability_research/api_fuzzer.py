"""
API Security Fuzzer
Performs security testing of REST APIs through spec fuzzing
"""

import logging
import asyncio
from typing import Dict, List, Any, Optional
import json
import random

logger = logging.getLogger(__name__)


class APISecurityFuzzer:
    """
    API security testing through specification-based fuzzing
    Tests REST APIs for injection, auth bypass, etc.
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.http_client = None  # Would use aiohttp or similar
        
    async def fuzz_api(self, api_spec: Dict[str, Any], base_url: str) -> Dict[str, Any]:
        """
        Fuzz API based on OpenAPI/Swagger specification
        
        Args:
            api_spec: OpenAPI specification
            base_url: Base URL of API
            
        Returns:
            Fuzzing results
        """
        logger.info(f"Fuzzing API: {base_url}")
        
        results = {
            'endpoints_tested': 0,
            'vulnerabilities': [],
            'errors': [],
            'interesting_responses': []
        }
        
        try:
            # Extract endpoints from spec
            endpoints = self._extract_endpoints(api_spec)
            
            for endpoint in endpoints:
                endpoint_results = await self._fuzz_endpoint(base_url, endpoint)
                results['endpoints_tested'] += 1
                results['vulnerabilities'].extend(endpoint_results.get('vulnerabilities', []))
                results['interesting_responses'].extend(endpoint_results.get('interesting', []))
            
            logger.info(f"API fuzzing complete: {results['endpoints_tested']} endpoints, "
                       f"{len(results['vulnerabilities'])} vulnerabilities")
            
            return results
            
        except Exception as e:
            logger.error(f"API fuzzing error: {e}")
            return {'error': str(e)}
    
    def _extract_endpoints(self, api_spec: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract endpoints from OpenAPI spec"""
        endpoints = []
        
        paths = api_spec.get('paths', {})
        
        for path, methods in paths.items():
            for method, spec in methods.items():
                if method.upper() in ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']:
                    endpoints.append({
                        'path': path,
                        'method': method.upper(),
                        'parameters': spec.get('parameters', []),
                        'requestBody': spec.get('requestBody', {}),
                        'security': spec.get('security', [])
                    })
        
        return endpoints
    
    async def _fuzz_endpoint(self, base_url: str, endpoint: Dict[str, Any]) -> Dict[str, Any]:
        """Fuzz a single API endpoint"""
        results = {'vulnerabilities': [], 'interesting': []}
        
        path = endpoint['path']
        method = endpoint['method']
        
        # Test cases
        test_cases = self._generate_test_cases(endpoint)
        
        for test_case in test_cases:
            try:
                response = await self._send_request(
                    base_url,
                    path,
                    method,
                    test_case
                )
                
                # Analyze response
                vulns = self._analyze_response(response, test_case, endpoint)
                results['vulnerabilities'].extend(vulns)
                
                if response.get('status_code') not in [200, 201, 400, 404]:
                    results['interesting'].append({
                        'endpoint': f"{method} {path}",
                        'status': response.get('status_code'),
                        'test_case': test_case['name']
                    })
                
            except Exception as e:
                logger.debug(f"Request error: {e}")
        
        return results
    
    def _generate_test_cases(self, endpoint: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate fuzzing test cases for endpoint"""
        test_cases = []
        
        # SQL Injection tests
        sql_payloads = [
            "' OR '1'='1",
            "1' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "1' AND 1=1--"
        ]
        
        for payload in sql_payloads:
            test_cases.append({
                'name': 'sql_injection',
                'type': 'injection',
                'payload': payload,
                'target': 'all_params'
            })
        
        # XSS tests
        xss_payloads = [
            "<script>alert('xss')</script>",
            "javascript:alert(1)",
            "<img src=x onerror=alert(1)>",
            "'-alert(1)-'"
        ]
        
        for payload in xss_payloads:
            test_cases.append({
                'name': 'xss',
                'type': 'injection',
                'payload': payload,
                'target': 'all_params'
            })
        
        # Command Injection
        cmd_payloads = [
            "; ls -la",
            "| cat /etc/passwd",
            "`whoami`",
            "$(id)"
        ]
        
        for payload in cmd_payloads:
            test_cases.append({
                'name': 'command_injection',
                'type': 'injection',
                'payload': payload,
                'target': 'all_params'
            })
        
        # Path Traversal
        path_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "....//....//....//etc/passwd"
        ]
        
        for payload in path_payloads:
            test_cases.append({
                'name': 'path_traversal',
                'type': 'injection',
                'payload': payload,
                'target': 'path_params'
            })
        
        # Auth bypass tests
        test_cases.extend([
            {
                'name': 'auth_bypass_no_token',
                'type': 'auth',
                'remove_auth': True
            },
            {
                'name': 'auth_bypass_invalid_token',
                'type': 'auth',
                'invalid_token': True
            }
        ])
        
        # IDOR tests
        test_cases.extend([
            {
                'name': 'idor_sequential',
                'type': 'idor',
                'id_manipulation': 'sequential'
            },
            {
                'name': 'idor_negative',
                'type': 'idor',
                'id_manipulation': 'negative'
            }
        ])
        
        # Mass assignment
        test_cases.append({
            'name': 'mass_assignment',
            'type': 'logic',
            'extra_fields': {'is_admin': True, 'role': 'admin'}
        })
        
        # Rate limiting
        test_cases.append({
            'name': 'rate_limiting',
            'type': 'logic',
            'repeat': 100
        })
        
        return test_cases
    
    async def _send_request(self, base_url: str, path: str, method: str,
                           test_case: Dict[str, Any]) -> Dict[str, Any]:
        """Send HTTP request for test case"""
        # This would use aiohttp or similar
        # Placeholder implementation
        
        url = base_url + path
        
        # Apply test case modifications
        params = {}
        headers = {}
        data = {}
        
        if 'payload' in test_case:
            # Inject payload into parameters
            params['test'] = test_case['payload']
            data = {'test': test_case['payload']}
        
        if test_case.get('remove_auth'):
            # Remove authorization header
            pass
        elif test_case.get('invalid_token'):
            headers['Authorization'] = 'Bearer invalid_token'
        
        # Simulate response
        response = {
            'status_code': 200,
            'body': '{"result": "success"}',
            'headers': {},
            'time': 0.1
        }
        
        return response
    
    def _analyze_response(self, response: Dict[str, Any], 
                         test_case: Dict[str, Any],
                         endpoint: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analyze response for vulnerabilities"""
        vulnerabilities = []
        
        status = response.get('status_code')
        body = response.get('body', '')
        
        # Check for SQL errors
        sql_errors = [
            'sql syntax',
            'mysql_fetch',
            'pg_query',
            'sqlite_',
            'ORA-'
        ]
        
        if test_case.get('name') == 'sql_injection':
            for error in sql_errors:
                if error.lower() in body.lower():
                    vulnerabilities.append({
                        'type': 'sql_injection',
                        'severity': 'critical',
                        'endpoint': f"{endpoint['method']} {endpoint['path']}",
                        'evidence': f"SQL error in response: {error}",
                        'test_case': test_case['name']
                    })
        
        # Check for XSS reflection
        if test_case.get('name') == 'xss':
            payload = test_case.get('payload', '')
            if payload in body:
                vulnerabilities.append({
                    'type': 'reflected_xss',
                    'severity': 'high',
                    'endpoint': f"{endpoint['method']} {endpoint['path']}",
                    'evidence': 'Payload reflected in response',
                    'payload': payload
                })
        
        # Check for path traversal success
        if test_case.get('name') == 'path_traversal':
            if 'root:' in body or 'Administrator' in body:
                vulnerabilities.append({
                    'type': 'path_traversal',
                    'severity': 'critical',
                    'endpoint': f"{endpoint['method']} {endpoint['path']}",
                    'evidence': 'System file content in response'
                })
        
        # Check for auth bypass
        if test_case.get('type') == 'auth':
            if status == 200:
                vulnerabilities.append({
                    'type': 'auth_bypass',
                    'severity': 'critical',
                    'endpoint': f"{endpoint['method']} {endpoint['path']}",
                    'evidence': 'Endpoint accessible without valid auth',
                    'test_case': test_case['name']
                })
        
        # Check for IDOR
        if test_case.get('type') == 'idor':
            if status == 200 and 'unauthorized' not in body.lower():
                vulnerabilities.append({
                    'type': 'idor',
                    'severity': 'high',
                    'endpoint': f"{endpoint['method']} {endpoint['path']}",
                    'evidence': 'Resource accessible with manipulated ID'
                })
        
        return vulnerabilities
