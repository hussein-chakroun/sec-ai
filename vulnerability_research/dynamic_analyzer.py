"""
Dynamic Binary Analysis Module
Runtime analysis with instrumentation
"""

import logging
import asyncio
import subprocess
from typing import Dict, List, Any
from pathlib import Path
import json

logger = logging.getLogger(__name__)


class DynamicAnalyzer:
    """
    Dynamic analysis using runtime instrumentation
    Monitors program behavior during execution
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.instrumentation_tool = config.get('tool', 'pin')  # PIN, DynamoRIO, Frida
        
    async def analyze(self, binary_path: str, test_inputs: List[bytes]) -> Dict[str, Any]:
        """
        Perform dynamic analysis on binary
        
        Args:
            binary_path: Path to binary
            test_inputs: Test inputs to execute with
            
        Returns:
            Analysis results
        """
        logger.info(f"Dynamic analysis: {binary_path}")
        
        results = {
            'binary': binary_path,
            'executions': 0,
            'coverage': {},
            'crashes': [],
            'memory_errors': [],
            'behavior': []
        }
        
        try:
            for i, test_input in enumerate(test_inputs):
                exec_result = await self._execute_instrumented(binary_path, test_input)
                results['executions'] += 1
                
                # Merge coverage
                self._merge_coverage(results['coverage'], exec_result.get('coverage', {}))
                
                # Record crashes
                if exec_result.get('crashed'):
                    results['crashes'].append({
                        'input_index': i,
                        'input': test_input.hex()[:200],
                        'crash_info': exec_result.get('crash_info')
                    })
                
                # Record memory errors
                if exec_result.get('memory_errors'):
                    results['memory_errors'].extend(exec_result['memory_errors'])
                
                # Record interesting behavior
                if exec_result.get('behavior'):
                    results['behavior'].append(exec_result['behavior'])
            
            logger.info(f"Dynamic analysis complete: {results['executions']} executions, "
                       f"{len(results['crashes'])} crashes")
            
            return results
            
        except Exception as e:
            logger.error(f"Dynamic analysis error: {e}")
            return {'error': str(e)}
    
    async def _execute_instrumented(self, binary_path: str, 
                                    test_input: bytes) -> Dict[str, Any]:
        """Execute binary with instrumentation"""
        result = {
            'crashed': False,
            'coverage': {},
            'memory_errors': [],
            'behavior': {}
        }
        
        try:
            # Use instrumentation framework
            if self.instrumentation_tool == 'pin':
                result = await self._execute_with_pin(binary_path, test_input)
            elif self.instrumentation_tool == 'frida':
                result = await self._execute_with_frida(binary_path, test_input)
            elif self.instrumentation_tool == 'valgrind':
                result = await self._execute_with_valgrind(binary_path, test_input)
            
        except Exception as e:
            logger.debug(f"Instrumented execution failed: {e}")
            result['error'] = str(e)
        
        return result
    
    async def _execute_with_pin(self, binary_path: str, test_input: bytes) -> Dict[str, Any]:
        """Execute with Intel PIN instrumentation"""
        result = {'crashed': False, 'coverage': {}}
        
        # Write input to temp file
        input_file = Path('temp_input')
        input_file.write_bytes(test_input)
        
        try:
            # PIN command with coverage tool
            cmd = [
                'pin',
                '-t', 'codecov.so',  # Coverage pintool
                '--',
                binary_path,
                str(input_file)
            ]
            
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=10)
                
                # Parse coverage output
                # PIN tools typically output coverage to files
                
            except asyncio.TimeoutError:
                proc.kill()
                result['timeout'] = True
            
        except Exception as e:
            logger.debug(f"PIN execution error: {e}")
        finally:
            if input_file.exists():
                input_file.unlink()
        
        return result
    
    async def _execute_with_frida(self, binary_path: str, test_input: bytes) -> Dict[str, Any]:
        """Execute with Frida dynamic instrumentation"""
        result = {'crashed': False, 'coverage': {}, 'behavior': {}}
        
        try:
            # Frida script for monitoring
            frida_script = """
            Interceptor.attach(Module.findExportByName(null, 'malloc'), {
                onEnter: function(args) {
                    send({type: 'malloc', size: args[0].toInt32()});
                }
            });
            
            Interceptor.attach(Module.findExportByName(null, 'free'), {
                onEnter: function(args) {
                    send({type: 'free', ptr: args[0]});
                }
            });
            """
            
            # Would use python-frida library here
            # import frida
            # session = frida.attach(process_name)
            # script = session.create_script(frida_script)
            
        except Exception as e:
            logger.debug(f"Frida execution error: {e}")
        
        return result
    
    async def _execute_with_valgrind(self, binary_path: str, 
                                     test_input: bytes) -> Dict[str, Any]:
        """Execute with Valgrind for memory error detection"""
        result = {'crashed': False, 'memory_errors': []}
        
        input_file = Path('temp_input')
        input_file.write_bytes(test_input)
        
        try:
            cmd = [
                'valgrind',
                '--leak-check=full',
                '--track-origins=yes',
                '--xml=yes',
                '--xml-file=valgrind_output.xml',
                binary_path,
                str(input_file)
            ]
            
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                await asyncio.wait_for(proc.communicate(), timeout=30)
                
                # Parse Valgrind XML output
                xml_file = Path('valgrind_output.xml')
                if xml_file.exists():
                    result['memory_errors'] = self._parse_valgrind_xml(xml_file)
                    xml_file.unlink()
                
            except asyncio.TimeoutError:
                proc.kill()
            
        except Exception as e:
            logger.debug(f"Valgrind execution error: {e}")
        finally:
            if input_file.exists():
                input_file.unlink()
        
        return result
    
    def _parse_valgrind_xml(self, xml_file: Path) -> List[Dict[str, Any]]:
        """Parse Valgrind XML output for memory errors"""
        errors = []
        
        try:
            # Would use XML parser here
            # import xml.etree.ElementTree as ET
            # tree = ET.parse(xml_file)
            # Find error elements and extract details
            
            # Placeholder
            errors.append({
                'type': 'memory_leak',
                'description': 'Memory leak detected',
                'location': 'unknown'
            })
            
        except Exception as e:
            logger.debug(f"Valgrind XML parsing error: {e}")
        
        return errors
    
    def _merge_coverage(self, existing: Dict, new: Dict):
        """Merge coverage data"""
        for key, value in new.items():
            if key not in existing:
                existing[key] = value
            elif isinstance(value, set):
                existing[key].update(value)
            elif isinstance(value, list):
                existing[key].extend(value)
    
    async def monitor_system_calls(self, binary_path: str, 
                                   test_input: bytes) -> List[Dict[str, Any]]:
        """
        Monitor system calls during execution
        
        Args:
            binary_path: Binary to execute
            test_input: Input to provide
            
        Returns:
            List of system calls made
        """
        logger.info("Monitoring system calls")
        
        syscalls = []
        input_file = Path('temp_input')
        input_file.write_bytes(test_input)
        
        try:
            # Use strace on Linux, dtruss on macOS, or similar
            cmd = ['strace', '-o', 'syscalls.txt', binary_path, str(input_file)]
            
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.DEVNULL,
                stderr=asyncio.subprocess.DEVNULL
            )
            
            await asyncio.wait_for(proc.wait(), timeout=10)
            
            # Parse strace output
            strace_file = Path('syscalls.txt')
            if strace_file.exists():
                syscalls = self._parse_strace(strace_file)
                strace_file.unlink()
            
        except Exception as e:
            logger.debug(f"Syscall monitoring error: {e}")
        finally:
            if input_file.exists():
                input_file.unlink()
        
        return syscalls
    
    def _parse_strace(self, strace_file: Path) -> List[Dict[str, Any]]:
        """Parse strace output"""
        syscalls = []
        
        try:
            content = strace_file.read_text()
            for line in content.split('\n'):
                # Basic parsing of strace output
                # Format: syscall(args) = result
                if '(' in line and ')' in line:
                    parts = line.split('(')
                    if len(parts) >= 2:
                        syscall_name = parts[0].strip()
                        syscalls.append({
                            'name': syscall_name,
                            'line': line.strip()
                        })
        except Exception as e:
            logger.debug(f"Strace parsing error: {e}")
        
        return syscalls
