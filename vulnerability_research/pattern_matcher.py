"""
Vulnerability Pattern Matching Module
Detects common vulnerability patterns in code and binaries
"""

import logging
from typing import Dict, List, Any
import re

logger = logging.getLogger(__name__)


class VulnerabilityPatternMatcher:
    """
    Pattern-based vulnerability detection
    Uses machine learning and signature matching
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.patterns = self._load_patterns()
        
    def scan(self, target: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Scan target for vulnerability patterns
        
        Args:
            target: Target information (code, binary, etc.)
            
        Returns:
            List of detected vulnerabilities
        """
        logger.info("Scanning for vulnerability patterns")
        
        vulnerabilities = []
        target_type = target.get('type', 'code')
        
        if target_type == 'code':
            vulnerabilities = self._scan_code_patterns(target)
        elif target_type == 'binary':
            vulnerabilities = self._scan_binary_patterns(target)
        
        logger.info(f"Found {len(vulnerabilities)} pattern matches")
        
        return vulnerabilities
    
    def _scan_code_patterns(self, target: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan source code for vulnerability patterns"""
        vulnerabilities = []
        code = target.get('code', '')
        language = target.get('language', 'unknown')
        
        patterns = self.patterns.get(language, {})
        
        for pattern_name, pattern_info in patterns.items():
            matches = re.finditer(pattern_info['pattern'], code, re.MULTILINE)
            
            for match in matches:
                vulnerabilities.append({
                    'type': pattern_name,
                    'category': pattern_info['category'],
                    'severity': pattern_info['severity'],
                    'line': code[:match.start()].count('\n') + 1,
                    'match': match.group(),
                    'description': pattern_info['description'],
                    'remediation': pattern_info.get('remediation', '')
                })
        
        return vulnerabilities
    
    def _scan_binary_patterns(self, target: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan binary for vulnerability patterns"""
        vulnerabilities = []
        
        # Binary pattern matching (e.g., gadget patterns, shellcode patterns)
        binary_data = target.get('data', b'')
        
        # Look for ROP gadgets
        rop_patterns = [
            (b'\xc3', 'ret'),  # ret instruction
            (b'\x5b\xc3', 'pop rbx; ret'),
            (b'\x5d\xc3', 'pop rbp; ret'),
        ]
        
        for pattern, description in rop_patterns:
            offset = 0
            while True:
                offset = binary_data.find(pattern, offset)
                if offset == -1:
                    break
                
                vulnerabilities.append({
                    'type': 'rop_gadget',
                    'offset': hex(offset),
                    'gadget': description,
                    'severity': 'info'
                })
                
                offset += 1
        
        return vulnerabilities
    
    def _load_patterns(self) -> Dict[str, Dict[str, Any]]:
        """Load vulnerability patterns"""
        return {
            'c': {
                'buffer_overflow': {
                    'pattern': r'\b(strcpy|strcat|sprintf|gets)\s*\([^)]*\)',
                    'category': 'memory_corruption',
                    'severity': 'high',
                    'description': 'Unsafe function that can cause buffer overflow',
                    'remediation': 'Use safe alternatives like strncpy, strncat, snprintf, fgets'
                },
                'format_string': {
                    'pattern': r'\b(printf|sprintf|fprintf)\s*\(\s*[a-zA-Z_][a-zA-Z0-9_]*\s*\)',
                    'category': 'injection',
                    'severity': 'high',
                    'description': 'Format string vulnerability - user input as format',
                    'remediation': 'Always use format specifiers: printf("%s", str)'
                },
                'use_after_free': {
                    'pattern': r'free\s*\([^)]+\)\s*;[^{]*\1',
                    'category': 'memory_corruption',
                    'severity': 'critical',
                    'description': 'Potential use-after-free vulnerability',
                    'remediation': 'Set pointer to NULL after free, check before use'
                },
                'integer_overflow': {
                    'pattern': r'malloc\s*\(\s*\w+\s*\*\s*\w+',
                    'category': 'memory_corruption',
                    'severity': 'medium',
                    'description': 'Integer overflow in size calculation',
                    'remediation': 'Check for overflow before multiplication'
                },
                'race_condition': {
                    'pattern': r'access\s*\([^)]+\)\s*;[^{]*open\s*\(',
                    'category': 'concurrency',
                    'severity': 'high',
                    'description': 'TOCTOU race condition',
                    'remediation': 'Use atomic operations or proper locking'
                }
            },
            'python': {
                'command_injection': {
                    'pattern': r'\b(os\.system|subprocess\.call|subprocess\.Popen|eval|exec)\s*\([^)]*[\+\%f][^)]*\)',
                    'category': 'injection',
                    'severity': 'critical',
                    'description': 'Command injection vulnerability',
                    'remediation': 'Use subprocess with list arguments, avoid eval/exec'
                },
                'sql_injection': {
                    'pattern': r'(execute|cursor\.execute)\s*\([^?]*[\+\%][^)]*\)',
                    'category': 'injection',
                    'severity': 'critical',
                    'description': 'SQL injection vulnerability',
                    'remediation': 'Use parameterized queries with placeholders'
                },
                'deserialization': {
                    'pattern': r'\bpickle\.loads?\s*\([^)]*\)',
                    'category': 'deserialization',
                    'severity': 'high',
                    'description': 'Unsafe deserialization with pickle',
                    'remediation': 'Validate and sanitize input, use JSON instead'
                },
                'path_traversal': {
                    'pattern': r'open\s*\([^)]*[\+][^)]*\)',
                    'category': 'path_traversal',
                    'severity': 'high',
                    'description': 'Path traversal vulnerability',
                    'remediation': 'Validate file paths, use os.path.join, check basedir'
                },
                'xxe': {
                    'pattern': r'(etree\.XML|etree\.fromstring|parseString)\s*\([^)]*\)',
                    'category': 'injection',
                    'severity': 'high',
                    'description': 'XXE vulnerability in XML parsing',
                    'remediation': 'Disable external entity processing in XML parser'
                }
            },
            'javascript': {
                'xss': {
                    'pattern': r'(\.innerHTML\s*=|document\.write\s*\(|\.html\s*\()',
                    'category': 'injection',
                    'severity': 'high',
                    'description': 'Cross-site scripting (XSS) vulnerability',
                    'remediation': 'Use textContent or sanitize HTML input'
                },
                'eval_injection': {
                    'pattern': r'\beval\s*\(',
                    'category': 'injection',
                    'severity': 'critical',
                    'description': 'Code injection via eval',
                    'remediation': 'Avoid eval, use JSON.parse for data'
                },
                'prototype_pollution': {
                    'pattern': r'\[\s*["\'](__proto__|constructor|prototype)["\']',
                    'category': 'prototype_pollution',
                    'severity': 'medium',
                    'description': 'Prototype pollution vulnerability',
                    'remediation': 'Validate object keys, use Map instead of objects'
                },
                'open_redirect': {
                    'pattern': r'(window\.location|location\.href)\s*=',
                    'category': 'redirect',
                    'severity': 'medium',
                    'description': 'Open redirect vulnerability',
                    'remediation': 'Validate URLs against whitelist'
                }
            },
            'java': {
                'deserialization': {
                    'pattern': r'ObjectInputStream.*readObject',
                    'category': 'deserialization',
                    'severity': 'critical',
                    'description': 'Unsafe Java deserialization',
                    'remediation': 'Implement custom readObject, validate class types'
                },
                'sql_injection': {
                    'pattern': r'Statement.*executeQuery.*\+',
                    'category': 'injection',
                    'severity': 'critical',
                    'description': 'SQL injection via string concatenation',
                    'remediation': 'Use PreparedStatement with parameters'
                },
                'xxe': {
                    'pattern': r'DocumentBuilderFactory.*newInstance',
                    'category': 'injection',
                    'severity': 'high',
                    'description': 'XXE vulnerability in XML parsing',
                    'remediation': 'Disable external entities and DOCTYPE'
                },
                'path_traversal': {
                    'pattern': r'new\s+File\s*\([^)]*\+',
                    'category': 'path_traversal',
                    'severity': 'high',
                    'description': 'Path traversal via file operations',
                    'remediation': 'Validate and normalize file paths'
                }
            }
        }
    
    async def ml_based_detection(self, code: str) -> List[Dict[str, Any]]:
        """
        Use machine learning for vulnerability detection
        
        Args:
            code: Source code to analyze
            
        Returns:
            ML-detected vulnerabilities
        """
        logger.info("Running ML-based vulnerability detection")
        
        # This would use a trained ML model
        # For now, return empty list as placeholder
        
        vulnerabilities = []
        
        # Example: Use code2vec, CodeBERT, or custom trained model
        # model = load_model('vuln_detection_model')
        # predictions = model.predict(code)
        
        return vulnerabilities
