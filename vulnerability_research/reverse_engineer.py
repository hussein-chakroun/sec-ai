"""
Reverse Engineering Automation Module
Automated binary reverse engineering and analysis
"""

import logging
from typing import Dict, List, Any, Optional
from pathlib import Path
import asyncio

logger = logging.getLogger(__name__)


class ReverseEngineer:
    """
    Automated reverse engineering of binaries
    Uses Ghidra, radare2, and other tools
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.tool = config.get('tool', 'radare2')  # radare2, ghidra, ida
        
    async def analyze(self, binary_path: str) -> Dict[str, Any]:
        """
        Perform automated reverse engineering
        
        Args:
            binary_path: Path to binary
            
        Returns:
            Reverse engineering results
        """
        logger.info(f"Reverse engineering: {binary_path}")
        
        results = {
            'binary': binary_path,
            'functions': [],
            'strings': [],
            'control_flow': {},
            'interesting_code': [],
            'decompiled': {}
        }
        
        try:
            if self.tool == 'radare2':
                results = await self._analyze_with_radare2(binary_path)
            elif self.tool == 'ghidra':
                results = await self._analyze_with_ghidra(binary_path)
            
            # Find interesting patterns
            results['interesting_code'] = self._find_interesting_patterns(results)
            
            logger.info(f"Reverse engineering complete: {len(results['functions'])} functions analyzed")
            
            return results
            
        except Exception as e:
            logger.error(f"Reverse engineering error: {e}")
            return {'error': str(e)}
    
    async def _analyze_with_radare2(self, binary_path: str) -> Dict[str, Any]:
        """Analyze binary using radare2"""
        results = {
            'functions': [],
            'strings': [],
            'imports': [],
            'exports': []
        }
        
        try:
            # Try using r2pipe if available
            import r2pipe
            
            r2 = r2pipe.open(binary_path)
            
            # Analyze binary
            r2.cmd('aaa')  # Analyze all
            
            # Get functions
            funcs = r2.cmdj('aflj')  # Functions as JSON
            if funcs:
                for func in funcs:
                    results['functions'].append({
                        'name': func.get('name', 'unknown'),
                        'address': hex(func.get('offset', 0)),
                        'size': func.get('size', 0),
                        'calls': func.get('callrefs', [])
                    })
            
            # Get strings
            strings = r2.cmdj('izj')  # Strings as JSON
            if strings:
                for s in strings[:100]:  # Limit to 100 strings
                    results['strings'].append({
                        'value': s.get('string', ''),
                        'address': hex(s.get('vaddr', 0))
                    })
            
            # Get imports
            imports = r2.cmdj('iij')
            if imports:
                results['imports'] = [imp.get('name', '') for imp in imports]
            
            r2.quit()
            
        except ImportError:
            logger.warning("r2pipe not available, using command-line radare2")
            results = await self._analyze_with_r2_cli(binary_path)
        except Exception as e:
            logger.warning(f"radare2 analysis error: {e}")
        
        return results
    
    async def _analyze_with_r2_cli(self, binary_path: str) -> Dict[str, Any]:
        """Analyze using radare2 command-line"""
        results = {'functions': [], 'strings': []}
        
        try:
            # Run radare2 commands
            cmd = ['r2', '-q', '-c', 'aaa;aflj', binary_path]
            
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, _ = await proc.communicate()
            
            # Parse JSON output
            import json
            try:
                funcs = json.loads(stdout.decode())
                if isinstance(funcs, list):
                    for func in funcs:
                        results['functions'].append({
                            'name': func.get('name', 'unknown'),
                            'address': hex(func.get('offset', 0)),
                            'size': func.get('size', 0)
                        })
            except:
                pass
            
        except Exception as e:
            logger.debug(f"r2 CLI error: {e}")
        
        return results
    
    async def _analyze_with_ghidra(self, binary_path: str) -> Dict[str, Any]:
        """Analyze binary using Ghidra headless analyzer"""
        results = {'functions': [], 'decompiled': {}}
        
        try:
            # Ghidra headless mode
            # analyzeHeadless <project_location> <project_name> -import <file> -postScript <script>
            
            project_dir = Path('ghidra_projects')
            project_dir.mkdir(exist_ok=True)
            
            cmd = [
                'analyzeHeadless',
                str(project_dir),
                'temp_project',
                '-import', binary_path,
                '-scriptPath', str(Path(__file__).parent / 'ghidra_scripts'),
                '-postScript', 'export_analysis.py'
            ]
            
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            await asyncio.wait_for(proc.communicate(), timeout=300)
            
            # Read exported analysis
            export_file = project_dir / 'analysis_export.json'
            if export_file.exists():
                import json
                results = json.loads(export_file.read_text())
                export_file.unlink()
            
        except Exception as e:
            logger.warning(f"Ghidra analysis error: {e}")
        
        return results
    
    def _find_interesting_patterns(self, analysis_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Find interesting code patterns in analysis results"""
        interesting = []
        
        # Look for crypto constants
        crypto_constants = [
            0x67452301,  # MD5
            0x6A09E667,  # SHA-256
            0x428a2f98,  # SHA-256
        ]
        
        # Look for interesting strings
        for string_entry in analysis_results.get('strings', []):
            string_val = string_entry.get('value', '').lower()
            
            # Hardcoded credentials
            if any(word in string_val for word in ['password', 'passwd', 'pwd', 'secret', 'key']):
                interesting.append({
                    'type': 'hardcoded_secret',
                    'value': string_entry,
                    'severity': 'high'
                })
            
            # URLs
            if 'http://' in string_val or 'https://' in string_val:
                interesting.append({
                    'type': 'url',
                    'value': string_entry,
                    'severity': 'low'
                })
            
            # File paths
            if '/' in string_val or '\\' in string_val:
                interesting.append({
                    'type': 'file_path',
                    'value': string_entry,
                    'severity': 'low'
                })
        
        # Look for dangerous functions
        dangerous_imports = ['system', 'exec', 'strcpy', 'gets']
        for import_name in analysis_results.get('imports', []):
            if any(dangerous in import_name for dangerous in dangerous_imports):
                interesting.append({
                    'type': 'dangerous_function',
                    'value': import_name,
                    'severity': 'medium'
                })
        
        return interesting
    
    async def decompile_function(self, binary_path: str, function_address: str) -> Optional[str]:
        """
        Decompile a specific function
        
        Args:
            binary_path: Binary file path
            function_address: Address of function to decompile
            
        Returns:
            Decompiled code or None
        """
        logger.info(f"Decompiling function at {function_address}")
        
        try:
            # Use Ghidra's decompiler or similar
            # This would invoke the decompiler on specific function
            
            decompiled = f"""
            // Decompiled function at {function_address}
            void function_{function_address}() {{
                // Decompiled code would appear here
            }}
            """
            
            return decompiled
            
        except Exception as e:
            logger.error(f"Decompilation error: {e}")
            return None
    
    async def find_vulnerable_functions(self, binary_path: str) -> List[Dict[str, Any]]:
        """
        Identify potentially vulnerable functions
        
        Args:
            binary_path: Binary to analyze
            
        Returns:
            List of potentially vulnerable functions
        """
        logger.info("Searching for vulnerable functions")
        
        analysis = await self.analyze(binary_path)
        vulnerable = []
        
        # Check each function
        for func in analysis.get('functions', []):
            func_name = func.get('name', '')
            
            # Check for common vulnerability indicators
            risk_score = 0
            reasons = []
            
            # Unsafe string operations
            if any(unsafe in func_name for unsafe in ['strcpy', 'strcat', 'sprintf', 'gets']):
                risk_score += 3
                reasons.append('Uses unsafe string function')
            
            # Buffer operations
            if 'copy' in func_name or 'move' in func_name:
                risk_score += 1
                reasons.append('Buffer operation')
            
            # Input handling
            if 'read' in func_name or 'input' in func_name or 'recv' in func_name:
                risk_score += 2
                reasons.append('Handles external input')
            
            if risk_score >= 2:
                vulnerable.append({
                    'function': func_name,
                    'address': func.get('address'),
                    'risk_score': risk_score,
                    'reasons': reasons
                })
        
        # Sort by risk score
        vulnerable.sort(key=lambda x: x['risk_score'], reverse=True)
        
        logger.info(f"Found {len(vulnerable)} potentially vulnerable functions")
        
        return vulnerable
