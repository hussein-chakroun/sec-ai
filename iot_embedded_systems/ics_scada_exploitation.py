"""
ICS/SCADA Exploitation Module
=============================

Industrial Control Systems and SCADA security testing:
- Modbus, DNP3, OPC protocol exploitation
- PLC programming and manipulation
- HMI vulnerability assessment
- Safety system bypass techniques

⚠️ CRITICAL WARNING: AUTHORIZED TESTING ONLY
===========================================
Testing ICS/SCADA systems without authorization is EXTREMELY DANGEROUS and ILLEGAL:
- Can cause physical damage to equipment
- Can cause safety hazards and endanger human life
- Can disrupt critical infrastructure
- Can result in severe legal penalties

NEVER test production ICS/SCADA systems without:
- Explicit written authorization
- Isolated test environment (air-gapped if possible)
- Safety system verification
- Emergency shutdown procedures
- Supervision by qualified personnel

This module is for AUTHORIZED SECURITY RESEARCH AND TESTING ONLY.
"""

import asyncio
import logging
import struct
import socket
from typing import List, Dict, Optional, Set, Tuple, Any
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum


logger = logging.getLogger(__name__)


class ICSProtocol(Enum):
    """Industrial control system protocols"""
    MODBUS = "modbus"
    DNP3 = "dnp3"
    OPC = "opc"
    S7COMM = "s7comm"
    BACNET = "bacnet"
    PROFINET = "profinet"
    ETHERCAT = "ethercat"
    UNKNOWN = "unknown"


class PLCType(Enum):
    """PLC manufacturer types"""
    SIEMENS = "siemens"
    ALLEN_BRADLEY = "allen_bradley"
    SCHNEIDER = "schneider"
    MITSUBISHI = "mitsubishi"
    ABB = "abb"
    GENERAL_ELECTRIC = "ge"
    UNKNOWN = "unknown"


class SafetyLevel(Enum):
    """ICS safety integrity levels (SIL)"""
    SIL_0 = "sil_0"  # No safety requirements
    SIL_1 = "sil_1"  # Low risk
    SIL_2 = "sil_2"  # Medium risk
    SIL_3 = "sil_3"  # High risk
    SIL_4 = "sil_4"  # Very high risk (rare)


@dataclass
class ICSDevice:
    """Represents an ICS/SCADA device"""
    ip_address: str
    protocol: ICSProtocol
    device_type: PLCType = PLCType.UNKNOWN
    model: Optional[str] = None
    firmware_version: Optional[str] = None
    port: int = 502  # Default Modbus port
    authenticated: bool = False
    safety_level: SafetyLevel = SafetyLevel.SIL_0
    vulnerabilities: List[str] = field(default_factory=list)
    coils: Dict[int, bool] = field(default_factory=dict)  # Modbus coils
    registers: Dict[int, int] = field(default_factory=dict)  # Modbus registers
    program_hash: Optional[str] = None


@dataclass
class PLCProgram:
    """Represents a PLC program/logic"""
    name: str
    language: str  # Ladder Logic, Structured Text, etc.
    size_bytes: int
    checksum: str
    safety_critical: bool = False
    rungs: List[Dict[str, Any]] = field(default_factory=list)  # Ladder logic rungs
    variables: Dict[str, Any] = field(default_factory=dict)
    comments: List[str] = field(default_factory=list)


class ModbusExploiter:
    """
    Modbus protocol exploitation.
    
    Modbus is the most common ICS protocol. Often has NO authentication or encryption.
    
    Function codes:
    - 01: Read Coils
    - 02: Read Discrete Inputs
    - 03: Read Holding Registers
    - 04: Read Input Registers
    - 05: Write Single Coil
    - 06: Write Single Register
    - 15: Write Multiple Coils
    - 16: Write Multiple Registers
    """
    
    DEFAULT_PORT = 502
    
    def __init__(self):
        self.discovered_devices = []
    
    async def scan_modbus_devices(self, target_network: str) -> List[ICSDevice]:
        """
        Scan network for Modbus devices.
        
        ⚠️ WARNING: Only scan networks you are authorized to test.
        """
        logger.info(f"Scanning for Modbus devices on {target_network}")
        
        devices = []
        
        # Simulate Modbus device discovery
        device_configs = [
            {
                "ip": "192.168.100.10",
                "type": PLCType.SIEMENS,
                "model": "S7-1200",
                "port": 502,
                "auth": False,
                "safety": SafetyLevel.SIL_2,
            },
            {
                "ip": "192.168.100.20",
                "type": PLCType.SCHNEIDER,
                "model": "Modicon M340",
                "port": 502,
                "auth": False,
                "safety": SafetyLevel.SIL_1,
            },
            {
                "ip": "192.168.100.30",
                "type": PLCType.ALLEN_BRADLEY,
                "model": "CompactLogix",
                "port": 502,
                "auth": True,
                "safety": SafetyLevel.SIL_3,
            },
        ]
        
        for config in device_configs:
            device = ICSDevice(
                ip_address=config["ip"],
                protocol=ICSProtocol.MODBUS,
                device_type=config["type"],
                model=config["model"],
                port=config["port"],
                authenticated=config["auth"],
                safety_level=config["safety"],
            )
            
            # Identify vulnerabilities
            if not device.authenticated:
                device.vulnerabilities.append("No authentication required")
            device.vulnerabilities.append("Unencrypted communication")
            device.vulnerabilities.append("Replay attacks possible")
            
            devices.append(device)
            logger.info(f"Found {device.device_type.value} at {device.ip_address} "
                       f"(SIL {device.safety_level.value})")
        
        return devices
    
    async def read_coils(self, device: ICSDevice, start_address: int, count: int) -> Dict[int, bool]:
        """
        Read coil status (discrete outputs).
        
        Modbus function code 01.
        """
        logger.info(f"Reading {count} coils from {device.ip_address} starting at {start_address}")
        
        if device.authenticated and not await self._authenticate(device):
            logger.error("Authentication failed")
            return {}
        
        # Simulate reading coils
        coils = {}
        for i in range(count):
            address = start_address + i
            # Simulate some coils being ON
            coils[address] = (i % 3 == 0)
        
        device.coils.update(coils)
        return coils
    
    async def write_coil(self, device: ICSDevice, address: int, value: bool) -> bool:
        """
        Write single coil (turn output ON/OFF).
        
        Modbus function code 05.
        
        ⚠️ DANGER: Can control physical equipment! Only use in authorized test environment.
        """
        logger.warning(f"WRITING coil {address} to {value} on {device.ip_address}")
        
        if device.safety_level.value >= SafetyLevel.SIL_2.value:
            logger.critical(f"WARNING: Device has safety rating {device.safety_level.value} - "
                          f"modifications could be dangerous!")
        
        if device.authenticated and not await self._authenticate(device):
            logger.error("Authentication failed")
            return False
        
        # Simulate write
        device.coils[address] = value
        logger.info(f"Coil {address} set to {value}")
        return True
    
    async def read_registers(self, device: ICSDevice, start_address: int, count: int) -> Dict[int, int]:
        """
        Read holding registers (analog values, setpoints, etc.).
        
        Modbus function code 03.
        """
        logger.info(f"Reading {count} registers from {device.ip_address} starting at {start_address}")
        
        # Simulate reading registers
        registers = {}
        for i in range(count):
            address = start_address + i
            # Simulate various register values
            registers[address] = 1000 + i * 100
        
        device.registers.update(registers)
        return registers
    
    async def write_register(self, device: ICSDevice, address: int, value: int) -> bool:
        """
        Write single holding register.
        
        Modbus function code 06.
        
        ⚠️ DANGER: Can modify setpoints and parameters! Extreme caution required.
        """
        logger.warning(f"WRITING register {address} to {value} on {device.ip_address}")
        
        if device.safety_level.value >= SafetyLevel.SIL_2.value:
            logger.critical(f"WARNING: Safety-critical device - writing register could cause harm!")
        
        # Simulate write
        device.registers[address] = value
        logger.info(f"Register {address} set to {value}")
        return True
    
    async def _authenticate(self, device: ICSDevice) -> bool:
        """Attempt authentication (if required)"""
        # Modbus typically has no authentication, but some implementations add it
        logger.info(f"Attempting authentication to {device.ip_address}")
        # Simulate auth
        return True


class DNP3Exploiter:
    """
    DNP3 (Distributed Network Protocol 3) exploitation.
    
    DNP3 is used in electric power and water/wastewater systems.
    More complex than Modbus but still often lacks proper security.
    """
    
    DEFAULT_PORT = 20000
    
    async def scan_dnp3_devices(self, target_network: str) -> List[ICSDevice]:
        """Scan for DNP3 devices (SCADA outstations)"""
        logger.info(f"Scanning for DNP3 devices on {target_network}")
        
        devices = []
        
        # Simulate DNP3 device discovery
        device_configs = [
            {
                "ip": "192.168.200.10",
                "type": PLCType.GENERAL_ELECTRIC,
                "model": "D20 RTU",
                "safety": SafetyLevel.SIL_3,
            },
            {
                "ip": "192.168.200.20",
                "type": PLCType.ABB,
                "model": "RTU560",
                "safety": SafetyLevel.SIL_2,
            },
        ]
        
        for config in device_configs:
            device = ICSDevice(
                ip_address=config["ip"],
                protocol=ICSProtocol.DNP3,
                device_type=config["type"],
                model=config["model"],
                port=self.DEFAULT_PORT,
                authenticated=False,
                safety_level=config["safety"],
            )
            
            device.vulnerabilities.extend([
                "No encryption by default",
                "Weak authentication (DNP3 Secure Authentication)",
                "Command injection possible",
                "Denial of service via malformed packets",
            ])
            
            devices.append(device)
        
        return devices
    
    async def read_analog_inputs(self, device: ICSDevice) -> Dict[str, float]:
        """Read analog input values (sensors)"""
        logger.info(f"Reading DNP3 analog inputs from {device.ip_address}")
        
        # Simulate reading SCADA sensor values
        inputs = {
            "voltage_phase_a": 240.5,
            "voltage_phase_b": 238.2,
            "voltage_phase_c": 241.1,
            "current_main": 125.3,
            "frequency": 60.01,
            "power_factor": 0.95,
        }
        
        return inputs
    
    async def send_control_command(self, device: ICSDevice, point: int, value: int) -> bool:
        """
        Send control command to DNP3 outstation.
        
        ⚠️ EXTREME DANGER: Controls power grid or water systems!
        """
        logger.critical(f"SENDING CONTROL COMMAND to {device.ip_address} - Point: {point}, Value: {value}")
        
        if device.safety_level == SafetyLevel.SIL_3 or device.safety_level == SafetyLevel.SIL_4:
            logger.critical("SAFETY CRITICAL SYSTEM - DO NOT PROCEED WITHOUT AUTHORIZATION!")
        
        # In real implementation, would send DNP3 control relay output block (CROB)
        logger.warning("Simulated control command sent")
        return True


class OPCExploiter:
    """
    OPC (OLE for Process Control) exploitation.
    
    OPC UA (Unified Architecture) is modern version with better security.
    OPC Classic (DA/HDA/AE) has weak security.
    """
    
    async def scan_opc_servers(self, target_network: str) -> List[ICSDevice]:
        """Scan for OPC servers"""
        logger.info(f"Scanning for OPC servers on {target_network}")
        
        devices = []
        
        # Simulate OPC server discovery
        device_configs = [
            {
                "ip": "192.168.300.10",
                "type": PLCType.SIEMENS,
                "model": "WinCC OPC Server",
                "port": 4840,  # OPC UA default port
                "version": "OPC UA",
            },
            {
                "ip": "192.168.300.20",
                "type": PLCType.SCHNEIDER,
                "model": "OPC Factory Server",
                "port": 135,  # OPC Classic (DCOM)
                "version": "OPC DA",
            },
        ]
        
        for config in device_configs:
            device = ICSDevice(
                ip_address=config["ip"],
                protocol=ICSProtocol.OPC,
                device_type=config["type"],
                model=config["model"],
                port=config["port"],
                firmware_version=config["version"],
            )
            
            if "OPC DA" in config["version"]:
                device.vulnerabilities.extend([
                    "OPC Classic uses DCOM - multiple security issues",
                    "No encryption by default",
                    "Windows authentication only",
                    "Vulnerable to relay attacks",
                ])
            else:
                device.vulnerabilities.extend([
                    "OPC UA - better security but check configuration",
                    "Weak security policies may be enabled",
                ])
            
            devices.append(device)
        
        return devices
    
    async def browse_tags(self, device: ICSDevice) -> List[str]:
        """Browse available OPC tags/variables"""
        logger.info(f"Browsing OPC tags on {device.ip_address}")
        
        # Simulate OPC tag discovery
        tags = [
            "Plant.Area1.Tank1.Level",
            "Plant.Area1.Tank1.Temperature",
            "Plant.Area1.Valve1.Position",
            "Plant.Area1.Pump1.Status",
            "Plant.Area1.Pump1.Speed",
            "Plant.Safety.EmergencyStop",
            "Plant.Safety.Alarm",
        ]
        
        return tags
    
    async def read_tag(self, device: ICSDevice, tag: str) -> Any:
        """Read OPC tag value"""
        logger.info(f"Reading tag '{tag}' from {device.ip_address}")
        
        # Simulate tag read
        if "Level" in tag:
            return 75.5  # Percentage
        elif "Temperature" in tag:
            return 82.3  # Celsius
        elif "Status" in tag:
            return "RUNNING"
        elif "EmergencyStop" in tag:
            return False
        
        return None
    
    async def write_tag(self, device: ICSDevice, tag: str, value: Any) -> bool:
        """
        Write OPC tag value.
        
        ⚠️ DANGER: Can control industrial processes!
        """
        logger.warning(f"WRITING tag '{tag}' = {value} on {device.ip_address}")
        
        if "Safety" in tag or "Emergency" in tag:
            logger.critical("ATTEMPTING TO MODIFY SAFETY SYSTEM - ABORT!")
            return False
        
        # Simulate write
        logger.info(f"Tag '{tag}' written successfully")
        return True


class PLCManipulator:
    """
    PLC program manipulation.
    
    Can:
    - Download PLC programs
    - Upload modified programs
    - Start/stop PLC
    - Modify logic on the fly
    """
    
    async def download_program(self, device: ICSDevice) -> Optional[PLCProgram]:
        """
        Download PLC program.
        
        ⚠️ WARNING: May alert operators or trigger security alarms.
        """
        logger.info(f"Downloading PLC program from {device.ip_address}")
        
        if device.safety_level.value >= SafetyLevel.SIL_2.value:
            logger.warning(f"Downloading from safety-critical PLC (SIL {device.safety_level.value})")
        
        # Simulate program download
        program = PLCProgram(
            name=f"{device.device_type.value}_main",
            language="Ladder Logic",
            size_bytes=256 * 1024,  # 256 KB
            checksum="abc123def456",
            safety_critical=(device.safety_level.value >= SafetyLevel.SIL_2.value),
        )
        
        # Simulate ladder logic rungs
        program.rungs = [
            {"rung": 0, "logic": "IF input_0 THEN output_0"},
            {"rung": 1, "logic": "IF NOT emergency_stop THEN motor_enable"},
            {"rung": 2, "logic": "IF temp > setpoint THEN cooling_on"},
        ]
        
        program.variables = {
            "input_0": "bool",
            "output_0": "bool",
            "emergency_stop": "bool",
            "motor_enable": "bool",
            "temp": "float",
            "setpoint": "float",
            "cooling_on": "bool",
        }
        
        logger.info(f"Program downloaded: {program.name} ({program.size_bytes} bytes)")
        return program
    
    async def upload_program(self, device: ICSDevice, program: PLCProgram) -> bool:
        """
        Upload modified PLC program.
        
        ⚠️ EXTREME DANGER: Can completely change PLC behavior!
        This could cause:
        - Equipment damage
        - Safety hazards
        - Production outages
        - Physical harm
        
        NEVER use on production systems!
        """
        logger.critical(f"UPLOADING PROGRAM TO PLC {device.ip_address}")
        
        if program.safety_critical:
            logger.critical("PROGRAM IS SAFETY CRITICAL - UPLOAD COULD BE CATASTROPHIC!")
            logger.critical("This operation should NEVER be performed on live systems!")
            return False
        
        # Simulate upload
        logger.warning(f"Program '{program.name}' uploaded to {device.ip_address}")
        device.program_hash = program.checksum
        return True
    
    async def modify_logic(self, program: PLCProgram, rung_number: int, new_logic: str) -> PLCProgram:
        """
        Modify PLC logic.
        
        Example attacks:
        - Disable safety interlocks
        - Change setpoints
        - Add backdoor conditions
        """
        logger.warning(f"Modifying ladder logic rung {rung_number}")
        
        if rung_number < len(program.rungs):
            old_logic = program.rungs[rung_number]["logic"]
            program.rungs[rung_number]["logic"] = new_logic
            logger.info(f"Changed: '{old_logic}' -> '{new_logic}'")
        
        return program
    
    async def stop_plc(self, device: ICSDevice) -> bool:
        """
        Stop PLC execution.
        
        ⚠️ DANGER: Will halt all control logic!
        """
        logger.critical(f"STOPPING PLC at {device.ip_address}")
        
        if device.safety_level.value >= SafetyLevel.SIL_1.value:
            logger.critical("Stopping PLC with active safety functions - DANGEROUS!")
        
        # Simulate PLC stop
        logger.warning("PLC stopped")
        return True


class HMIVulnerabilityScanner:
    """
    HMI (Human-Machine Interface) vulnerability scanner.
    
    HMIs often run Windows and have web interfaces with poor security.
    """
    
    async def scan_hmi(self, ip_address: str) -> Dict[str, Any]:
        """Scan HMI for vulnerabilities"""
        logger.info(f"Scanning HMI at {ip_address}")
        
        results = {
            "ip": ip_address,
            "hmi_type": "SCADA WebHMI",
            "os": "Windows Server 2012",
            "web_interface": True,
            "default_credentials": [],
            "vulnerabilities": [],
            "exposed_services": [],
        }
        
        # Simulate vulnerability discovery
        results["exposed_services"] = [
            {"port": 80, "service": "HTTP - Unencrypted web interface"},
            {"port": 443, "service": "HTTPS - Self-signed certificate"},
            {"port": 3389, "service": "RDP - Remote Desktop"},
            {"port": 445, "service": "SMB - File sharing"},
        ]
        
        results["default_credentials"] = [
            ("admin", "admin"),
            ("operator", "operator"),
        ]
        
        results["vulnerabilities"] = [
            "CVE-2019-12345: Authentication bypass in web interface",
            "CVE-2020-67890: SQL injection in login form",
            "Outdated Windows Server (unsupported)",
            "RDP exposed to network",
            "Default credentials active",
            "No HTTPS enforcement",
            "Directory traversal in file download",
        ]
        
        logger.warning(f"Found {len(results['vulnerabilities'])} HMI vulnerabilities")
        return results


class SafetySystemAnalyzer:
    """
    Safety system analysis and bypass detection.
    
    ⚠️ CRITICAL: This module is for SECURITY RESEARCH ONLY.
    Bypassing safety systems can cause serious harm or death.
    """
    
    async def analyze_safety_systems(self, device: ICSDevice) -> Dict[str, Any]:
        """
        Analyze safety system implementation.
        
        Checks for:
        - Safety PLC configuration
        - Emergency stop circuits
        - Safety-rated I/O
        - Redundancy
        - Bypass vulnerabilities
        """
        logger.info(f"Analyzing safety systems on {device.ip_address}")
        
        results = {
            "device": device.ip_address,
            "safety_level": device.safety_level.value,
            "safety_plc": False,
            "emergency_stops": 0,
            "redundancy": "None",
            "bypass_opportunities": [],
            "recommendations": [],
        }
        
        # Simulate safety analysis
        if device.safety_level.value >= SafetyLevel.SIL_2.value:
            results["safety_plc"] = True
            results["emergency_stops"] = 3
            results["redundancy"] = "Dual channel"
        
        # Identify potential bypass methods (for security testing!)
        if not results["redundancy"] or results["redundancy"] == "None":
            results["bypass_opportunities"].append({
                "method": "Single point of failure",
                "description": "No redundant safety channels - single component failure could disable safety",
                "severity": "HIGH",
            })
        
        if device.authenticated == False:
            results["bypass_opportunities"].append({
                "method": "Unauthenticated access",
                "description": "Safety PLC accessible without authentication - could modify safety logic",
                "severity": "CRITICAL",
            })
        
        # Generate recommendations
        if results["bypass_opportunities"]:
            results["recommendations"].extend([
                "Implement hardware-based safety systems independent of PLC",
                "Use safety-rated PLCs with TÜV certification",
                "Add authentication and encryption to all safety communications",
                "Implement physical tamper detection",
                "Regular safety system audits",
            ])
        
        return results


class ICSExploiter:
    """
    Main orchestrator for ICS/SCADA exploitation.
    
    ⚠️ CRITICAL WARNING ⚠️
    This tool combines multiple ICS attack techniques.
    Misuse can cause:
    - Equipment damage
    - Production outages
    - Safety incidents
    - Environmental damage
    - Loss of life
    
    ONLY use in isolated test environments with proper authorization and safety measures.
    """
    
    def __init__(self):
        self.modbus = ModbusExploiter()
        self.dnp3 = DNP3Exploiter()
        self.opc = OPCExploiter()
        self.plc_manipulator = PLCManipulator()
        self.hmi_scanner = HMIVulnerabilityScanner()
        self.safety_analyzer = SafetySystemAnalyzer()
    
    async def run_full_assessment(self, target_network: str) -> Dict[str, Any]:
        """
        Run comprehensive ICS/SCADA security assessment.
        
        ⚠️ WARNING: This will actively probe ICS devices.
        Only run on isolated test networks with authorization.
        
        Args:
            target_network: Network to scan (e.g., "192.168.100.0/24")
        
        Returns:
            Complete assessment results
        """
        logger.critical("=" * 60)
        logger.critical("STARTING ICS/SCADA SECURITY ASSESSMENT")
        logger.critical("WARNING: Only proceed if you have explicit authorization!")
        logger.critical("=" * 60)
        
        results = {
            "assessment_time": datetime.now().isoformat(),
            "target_network": target_network,
            "devices_found": [],
            "modbus_devices": [],
            "dnp3_devices": [],
            "opc_servers": [],
            "hmi_vulnerabilities": [],
            "safety_analysis": [],
            "plc_programs": [],
            "critical_findings": [],
            "recommendations": [],
        }
        
        # Phase 1: Modbus scanning
        logger.info("Phase 1: Modbus device discovery")
        modbus_devices = await self.modbus.scan_modbus_devices(target_network)
        results["modbus_devices"] = [
            {
                "ip": dev.ip_address,
                "type": dev.device_type.value,
                "model": dev.model,
                "safety_level": dev.safety_level.value,
                "vulnerabilities": dev.vulnerabilities,
            }
            for dev in modbus_devices
        ]
        results["devices_found"].extend(modbus_devices)
        
        # Phase 2: DNP3 scanning
        logger.info("Phase 2: DNP3 device discovery")
        dnp3_devices = await self.dnp3.scan_dnp3_devices(target_network)
        results["dnp3_devices"] = [
            {
                "ip": dev.ip_address,
                "type": dev.device_type.value,
                "model": dev.model,
                "safety_level": dev.safety_level.value,
                "vulnerabilities": dev.vulnerabilities,
            }
            for dev in dnp3_devices
        ]
        results["devices_found"].extend(dnp3_devices)
        
        # Phase 3: OPC server discovery
        logger.info("Phase 3: OPC server discovery")
        opc_servers = await self.opc.scan_opc_servers(target_network)
        results["opc_servers"] = [
            {
                "ip": dev.ip_address,
                "model": dev.model,
                "version": dev.firmware_version,
                "vulnerabilities": dev.vulnerabilities,
            }
            for dev in opc_servers
        ]
        results["devices_found"].extend(opc_servers)
        
        # Phase 4: Test Modbus read/write
        logger.info("Phase 4: Modbus exploitation testing")
        for device in modbus_devices[:1]:  # Test first device only
            coils = await self.modbus.read_coils(device, 0, 10)
            registers = await self.modbus.read_registers(device, 0, 10)
        
        # Phase 5: HMI vulnerability scanning
        logger.info("Phase 5: HMI vulnerability scanning")
        hmi_result = await self.hmi_scanner.scan_hmi("192.168.100.50")
        results["hmi_vulnerabilities"].append(hmi_result)
        
        # Phase 6: Safety system analysis
        logger.info("Phase 6: Safety system analysis")
        for device in results["devices_found"]:
            if device.safety_level.value >= SafetyLevel.SIL_1.value:
                safety_result = await self.safety_analyzer.analyze_safety_systems(device)
                results["safety_analysis"].append(safety_result)
        
        # Phase 7: PLC program analysis (simulation only)
        logger.info("Phase 7: PLC program analysis")
        for device in modbus_devices[:1]:
            if device.device_type in [PLCType.SIEMENS, PLCType.ALLEN_BRADLEY]:
                program = await self.plc_manipulator.download_program(device)
                if program:
                    results["plc_programs"].append({
                        "device": device.ip_address,
                        "program_name": program.name,
                        "size": program.size_bytes,
                        "safety_critical": program.safety_critical,
                        "rungs": len(program.rungs),
                    })
        
        # Identify critical findings
        results["critical_findings"] = self._identify_critical_findings(results)
        
        # Generate recommendations
        results["recommendations"] = self._generate_recommendations(results)
        
        logger.info(f"Assessment complete - {len(results['devices_found'])} devices, "
                   f"{len(results['critical_findings'])} critical findings")
        
        return results
    
    def _identify_critical_findings(self, results: Dict[str, Any]) -> List[str]:
        """Identify critical security findings"""
        findings = []
        
        # Unauthenticated safety-critical devices
        for device_list in [results["modbus_devices"], results["dnp3_devices"]]:
            for dev in device_list:
                if dev["safety_level"] in ["sil_2", "sil_3", "sil_4"]:
                    findings.append(
                        f"CRITICAL: Safety-critical device {dev['ip']} ({dev['safety_level']}) "
                        f"accessible without authentication"
                    )
        
        # HMI with default credentials
        for hmi in results["hmi_vulnerabilities"]:
            if hmi.get("default_credentials"):
                findings.append(
                    f"CRITICAL: HMI {hmi['ip']} has active default credentials"
                )
        
        # Safety system bypass opportunities
        for safety in results["safety_analysis"]:
            if safety.get("bypass_opportunities"):
                for bypass in safety["bypass_opportunities"]:
                    if bypass["severity"] == "CRITICAL":
                        findings.append(
                            f"CRITICAL: Safety bypass possible - {bypass['description']}"
                        )
        
        return findings
    
    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate security recommendations"""
        recommendations = [
            "Network Segmentation:",
            "- Isolate ICS network from corporate network",
            "- Implement firewall between safety PLCs and regular PLCs",
            "- Use air-gapped networks for SIL 3/4 systems",
            "",
            "Access Control:",
            "- Implement authentication on all ICS protocols",
            "- Use role-based access control (RBAC)",
            "- Change all default credentials",
            "- Implement two-factor authentication for HMIs",
            "",
            "Monitoring:",
            "- Deploy ICS-specific intrusion detection (IDS)",
            "- Log all PLC program uploads/downloads",
            "- Monitor for unauthorized Modbus/DNP3 writes",
            "- Alert on safety system modifications",
            "",
            "Hardening:",
            "- Disable unused protocols and services",
            "- Update HMI operating systems and software",
            "- Implement encrypted communications (TLS/VPN)",
            "- Use hardware-based safety systems where possible",
            "",
            "Incident Response:",
            "- Develop ICS-specific incident response plan",
            "- Train operators on cybersecurity awareness",
            "- Maintain offline backups of PLC programs",
            "- Test emergency shutdown procedures",
        ]
        
        return recommendations
